<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Dex</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<blockquote>
<p>所有信息都来自</p>

<p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html">dex-format</a>、<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html">davik-bytecode</a>、<a href="https://source.android.com/devices/tech/dalvik/instruction-formats.html">instruction-formats</a>以及AOSP的<code>AOSP/dalvik/libdex/</code>目录下源码，<code>leb128</code>的解码源码在<code>AOSP/libcore/dex/src/main/java/com/android/dex/Leb128.java</code>。</p>
</blockquote>

<p>Dex：Dalvik Executable format，即Dalvik可执行文件格式。实际上在5.0之前的设备上，第一次打开应用时会执行<code>dexopt</code>，即dex优化，这个过程会生成<code>odex</code>文件，以后每次都直接加载优化过后的<code>odex</code>文件（2.x的机子上这个过程非常慢，经常导致应用第一次启动时黑屏，甚至ANR）；在5.0及以后，Android不再使用Dalvik，新的虚拟机为ART，不过dex仍然是必须的，ART也会进行dex优化，名为<code>dex2oat</code>，这个过程和Dalvik不一样，是在安装时进行的，所以5.0及以后的设备安装应用的过程会比较耗时。<code>dexopt</code>和<code>dex2oat</code>不在本文讨论范围。</p>

<p>在动手之前，有两个非常重要的概念需要了解一下：</p>

<h3 id="toc_0">字节序</h3>

<p>即字节顺序，分为大端序、小端序和混合序。详细可以参考<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">维基百科</a>，这里以Dex文件结构简单说一下，从freeline的产出文件中拿到一个classes.dex文件，查看大小为<code>12296</code>字节，十六进制是<code>0x3008</code>，如果以大端序存储，应该为<code>00 00 30 08</code>，小端序应该为<code>08 30 00 00</code>（数据以8bit为单位存储）。</p>

<h3 id="toc_1">Leb128</h3>

<p>Little-Endian Base 128，详细信息在<a href="http://dwarfstd.org/Dwarf3Std.php">DWARF3</a>。简单点说就是数据可变长度的编码方式，在dex文件中，使用0－5位字节来编码32位整数。数据存储方式也是小端序，如果第一个字节的最高位是1，则继续读下一个字节，依次读取，最多只能读5个字节，如果第5个字节还是1则dex无效。</p>

<p>Leb128有3种类型：<code>sleb128</code>（signed LEB128，编码序列的最后1位表示值的符号，1表示负数）、<code>uleb128</code>（unsigned LEB128）和<code>uleb128p1</code>（<code>uleb128</code>的值减一）。举个🌰，解码<code>leb128</code>编码的值<code>80 7f</code>，二进制存储方式为<code>1000 0000 0111 1111</code>：</p>

<p><code>sleb128</code>：总共有两个字节，编码序列的最后一位为1，表示这是一个负数，真实值的二进制编码（补码）为<code>-11111 1000 0000</code>，原码为<code>-1000 0000</code>，也即<code>-128</code>。</p>

<p><code>uleb128</code>：这个比较简单，分别取掉两个字节的最高位，结果为<code>000 0000 111 1111</code>，真实值也就是<code>111 1111 000 0000</code>，也即<code>16256</code></p>

<p><code>uleb128p1</code>：这个的值就是<code>uleb128</code>的值减1。</p>

<p><code>AOSP</code>中提供了解码<code>leb128</code>的<code>c</code>和<code>java</code>代码。</p>

<h2 id="toc_2">Dex文件结构</h2>

<p>从<a href="https://source.android.com/devices/tech/dalvik/dex-format.html#file-layout">官方文档</a>中可以看到，一个<code>.dex</code>文件主要分为3层：头信息、索引表、数据区。其中索引表中又分为了<code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code>、<code>field_ids</code>、<code>method_ids</code>、<code>class_defs</code>。</p>

<p>后面再一步步仔细分析，先简单说一下：头信息中存储了文件的一些概要信息，比如文件大小、版本、校验信息、还有<code>string</code>的数量及<code>string_ids</code>在文件中的位置、<code>type</code>的数量以及<code>type_ids</code>在文件中的位置等等。</p>

<p>根据头信息中的数据可以找到各种索引区的位置，然后在索引区的数据中可以找到当前类型数据在文件中的存储位置。比如下面<code>Hello.dex</code>中，从头信息中可以知道有14个<code>string</code>以及<code>string_ids</code>的位置，解析<code>string_id</code>可以得到字符串的位置。</p>

<h3 id="toc_3">实战</h3>

<p>掌握上面的知识后，我们就可以结合<a href="https://source.android.com/devices/tech/dalvik/dex-format.html#file-layout">官方文档</a>和AOSP源码来解析一个<code>.dex</code>文件了。AOSP中用到的文件有：</p>

<div><pre><code class="language-none">dalvik/libdex/DexFile.h
dalvik/libdex/DexFile.cpp
dalvik/libdex/DexClass.h
libcore/dex/src/main/java/com/android/dex/Leb128.java</code></pre></div>

<h3 id="toc_4">Hello World</h3>

<p>我们来生成一个最简单的<code>.dex</code>文件。</p>

<p>首先，写一个<code>HelloWorld.java</code>：</p>

<div><pre><code class="language-none">public class HelloWorld {
  public static void main(String[] argc) {
    System.out.println(&quot;Hello, Dex!\n&quot;);
  }
}</code></pre></div>

<p>编译为<code>.class</code>文件，我本地<code>jdk</code>版本为1.8，所以需要加参数：</p>

<p><code>javac HelloWorld.java -source 1.7 -target 1.7</code></p>

<p>将<code>.class</code>文件编译为<code>.dex</code>文件：</p>

<p><code>dx --dex --output=Hello.dex HelloWorld.class</code></p>

<p>最后产出<code>Hello.dex</code>文件。</p>

<h3 id="toc_5">Header Section</h3>

<table>
<thead>
<tr>
<th>name</th>
<th>format</th>
<th>description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>magic</code></td>
<td><code>ubyte[8]</code></td>
<td>魔术，用来识别<code>.dex</code>文件，绝大多数的<code>.dex</code>文件值为<code>dex\n035\0</code></td>
</tr>
<tr>
<td><code>checksum</code></td>
<td><code>uint</code></td>
<td>除<code>magic</code>和<code>checksum</code>外所有字节的<code>adler32</code>值</td>
</tr>
<tr>
<td><code>signature</code></td>
<td><code>ubyte[20]</code></td>
<td>除<code>magic</code>、<code>checksum</code>、<code>signature</code>外所有字节的<code>SHA-1</code></td>
</tr>
<tr>
<td><code>file_size</code></td>
<td><code>uint</code></td>
<td>文件大小</td>
</tr>
<tr>
<td><code>header_size</code></td>
<td><code>uint</code></td>
<td>Header Section的大小，固定为0x70也就是112字节</td>
</tr>
<tr>
<td><code>endian_tag</code></td>
<td><code>uint</code></td>
<td>大小端标记，<code>.dex</code>固定为<code>78563412</code></td>
</tr>
<tr>
<td><code>link_size</code></td>
<td><code>uint</code></td>
<td>保留字段，并没有用到，值为0</td>
</tr>
<tr>
<td><code>link_off</code></td>
<td><code>uint</code></td>
<td>保留字段，并没有用到，值为0</td>
</tr>
<tr>
<td><code>map_off</code></td>
<td><code>uint</code></td>
<td>map数据的位置，必定为非0值</td>
</tr>
<tr>
<td><code>string_ids_size</code></td>
<td><code>uint</code></td>
<td><code>string</code>的数量，可以为0</td>
</tr>
<tr>
<td><code>string_ids_off</code></td>
<td><code>uint</code></td>
<td><code>string_id</code>列表的位置，可以为0</td>
</tr>
<tr>
<td><code>type_ids_size</code></td>
<td><code>uint</code></td>
<td><code>type</code>的数量，可以为0，最大值为65535</td>
</tr>
<tr>
<td><code>type_ids_off</code></td>
<td><code>uint</code></td>
<td><code>type_id</code>列表的位置，可以为0</td>
</tr>
<tr>
<td><code>proto_ids_size</code></td>
<td><code>uint</code></td>
<td><code>prototype</code>的数量，最大值为65535</td>
</tr>
<tr>
<td><code>proto_ids_off</code></td>
<td><code>uint</code></td>
<td><code>proto_id</code>列表的位置，可以为0</td>
</tr>
<tr>
<td><code>field_ids_size</code></td>
<td><code>uint</code></td>
<td><code>field</code>的数量，可以为0</td>
</tr>
<tr>
<td><code>field_ids_off</code></td>
<td><code>uint</code></td>
<td><code>field_id</code>列表的位置，可以为0</td>
</tr>
<tr>
<td><code>method_ids_size</code></td>
<td><code>uint</code></td>
<td><code>method</code>的数量，可以为0</td>
</tr>
<tr>
<td><code>method_ids_off</code></td>
<td><code>uint</code></td>
<td><code>method_id</code>列表的数量，可以为0</td>
</tr>
<tr>
<td><code>class_defs_size</code></td>
<td><code>uint</code></td>
<td>类定义（class definitions）的数量，可以为0</td>
</tr>
<tr>
<td><code>class_defs_off</code></td>
<td><code>uint</code></td>
<td>类定义列表的位置</td>
</tr>
<tr>
<td><code>data_size</code></td>
<td><code>uint</code></td>
<td>数据区大小</td>
</tr>
<tr>
<td><code>data_off</code></td>
<td><code>uint</code></td>
<td>数据区的位置</td>
</tr>
</tbody>
</table>

<p>Header Section的结构就是这样，解析的代码我们可以使用<code>Okio</code>，<code>Okio</code>中提供了小端存储数据的读取方法，如<code>readIntLe()</code>、<code>readShortLe()</code>等，非常方便。</p>

<p>代码如下：</p>

<div><pre><code class="language-none">public static DexHeader parse(File DEX) throws IOException {
        DexHeader dexHeader = new DexHeader();
        BufferedSource buffer = Okio.buffer(Okio.source(DEX));
        dexHeader.magic = Utils.readByteString(buffer, 8).utf8();
        dexHeader.checksum = Utils.readByteString(buffer, 4).hex();
        dexHeader.signature = Utils.readByteString(buffer, 20).hex();
        dexHeader.fileSize = buffer.readIntLe();
        dexHeader.headerSize = buffer.readIntLe();
        dexHeader.endianTag = Utils.readByteString(buffer, 4).hex();
        dexHeader.linkSize = buffer.readIntLe();
        dexHeader.linkOff = buffer.readIntLe();
        dexHeader.mapOff = buffer.readIntLe();
        dexHeader.stringIdsSize = buffer.readIntLe();
        dexHeader.stringIdsOff = buffer.readIntLe();
        dexHeader.typeIdsSize = buffer.readIntLe();
        dexHeader.typeIdsOff = buffer.readIntLe();
        dexHeader.protoIdsSize = buffer.readIntLe();
        dexHeader.protoIdsOff = buffer.readIntLe();
        dexHeader.fieldIdsSize = buffer.readIntLe();
        dexHeader.fieldIdsOff = buffer.readIntLe();
        dexHeader.methodIdsSize = buffer.readIntLe();
        dexHeader.methodIdsOff = buffer.readIntLe();
        dexHeader.classDefsSize = buffer.readIntLe();
        dexHeader.classDefsOff = buffer.readIntLe();
        dexHeader.dataSize = buffer.readIntLe();
        dexHeader.dataOff = buffer.readIntLe();
        return dexHeader;
    }</code></pre></div>

<p>结果为：</p>

<table>
<thead>
<tr>
<th>name</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>magic</code></td>
<td><code>dex\n035\0</code></td>
</tr>
<tr>
<td><code>checksum</code></td>
<td><code>1d5fbfb9</code></td>
</tr>
<tr>
<td><code>signature</code></td>
<td><code>bbcc4e506837a4d62250491c6b9eac195cf5269d</code></td>
</tr>
<tr>
<td><code>file_size</code></td>
<td><code>744</code></td>
</tr>
<tr>
<td><code>header_size</code></td>
<td><code>112</code></td>
</tr>
<tr>
<td><code>endian_tag</code></td>
<td><code>78563412</code></td>
</tr>
<tr>
<td><code>link_size</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>link_off</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>map_off</code></td>
<td><code>584</code></td>
</tr>
<tr>
<td><code>string_ids_size</code></td>
<td><code>14</code></td>
</tr>
<tr>
<td><code>string_ids_off</code></td>
<td><code>112</code></td>
</tr>
<tr>
<td><code>type_ids_size</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>type_ids_off</code></td>
<td><code>168</code></td>
</tr>
<tr>
<td><code>proto_ids_size</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>proto_ids_off</code></td>
<td><code>196</code></td>
</tr>
<tr>
<td><code>field_ids_size</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>field_ids_off</code></td>
<td><code>232</code></td>
</tr>
<tr>
<td><code>method_ids_size</code></td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>method_ids_off</code></td>
<td><code>240</code></td>
</tr>
<tr>
<td><code>class_defs_size</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>class_defs_off</code></td>
<td><code>272</code></td>
</tr>
<tr>
<td><code>data_size</code></td>
<td><code>440</code></td>
</tr>
<tr>
<td><code>data_off</code></td>
<td><code>304</code></td>
</tr>
</tbody>
</table>

<p>我们可以验证一下<code>checksum</code>和<code>signature</code>：</p>

<div><pre><code class="language-none">private static void verifyCheckSum(File DEX, DexFile dexFile) throws IOException {
        BufferedSource source = Okio.buffer(Okio.source(DEX));
        source.skip(8);// magic
        source.skip(4);// checksum
        Adler32 adler32 = new Adler32();
        adler32.update(source.readByteArray());
        Buffer buffer = new Buffer();
        buffer.writeIntLe((int) adler32.getValue());
        String checksum = buffer.readByteString().hex();
        System.out.println(checksum.equals(dexFile.dexHeader.checksum));
    }
    
private static void verifySignature(File DEX, DexFile dexFile) throws IOException {
        BufferedSource source = Okio.buffer(Okio.source(DEX));
        source.skip(8);// magic
        source.skip(4);// checksum
        source.skip(20);// signature
        String signature = source.readByteString().sha1().hex();
        System.out.println(signature.equals(dexFile.dexHeader.signature));
    }</code></pre></div>

<p>结果都为<code>true</code>。</p>

<h3 id="toc_6">String</h3>

<p>从Header中可以知道<code>string_ids</code>区的位置，这个区中存储的是<code>string_id_item</code>的列表，<code>string_id_item</code>中存储的是一个名为<code>string_data_off</code>的<code>uint</code>类型值，这个值表示对应的<code>string_data_item</code>在文件中的位置，详情如下：</p>

<p><code>string_id_item</code>的结构：</p>

<table>
<thead>
<tr>
<th>name</th>
<th>format</th>
<th>description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>string_data_off</code></td>
<td><code>uint</code></td>
<td>对应的<code>string_data_item</code>在文件中的位置</td>
</tr>
</tbody>
</table>

<p><code>string_data_item</code>的结构：</p>

<table>
<thead>
<tr>
<th>name</th>
<th>format</th>
<th>description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>utf16_size</code></td>
<td><code>uleb128</code></td>
<td>字符串长度</td>
</tr>
<tr>
<td><code>data</code></td>
<td><code>ubyte[]</code></td>
<td>字符串的内容，MUTF-8格式</td>
</tr>
</tbody>
</table>

<p>解析数据：</p>

<div><pre><code class="language-none">public static ArrayList&lt;DexStringId&gt; parse(File DEX, DexHeader dexHeader) throws IOException {
        BufferedSource buffer = Okio.buffer(Okio.source(DEX));
        buffer.skip(dexHeader.stringIdsOff);
        int len = dexHeader.stringIdsSize;
        ArrayList&lt;DexStringId&gt; dexStringIds = new ArrayList&lt;&gt;(len);
        for (int i = 0; i &lt; len; i++) {
            DexStringId dexStringId = new DexStringId();
            dexStringId.stringDataOff = buffer.readIntLe();
            dexStringIds.add(dexStringId);
        }
        return dexStringIds;
    }

public static ArrayList&lt;StringDataItem&gt; parse(File DEX, List&lt;DexStringId&gt; dexStringIds) throws IOException {
        ArrayList&lt;StringDataItem&gt; stringDataItems = new ArrayList&lt;&gt;(dexStringIds.size());
        int len = dexStringIds.size();
        System.err.println(&quot;len &quot; + len);
        for (int i = 0; i &lt; len; i++) {
            BufferedSource bufferedSource = Okio.buffer(Okio.source(DEX));
            bufferedSource.skip(dexStringIds.get(i).stringDataOff);
            StringDataItem stringDataItem = new StringDataItem();
            int leb128 = Utils.readUnsignedLeb128_4(bufferedSource);
            stringDataItem.utf16_size = leb128;
            stringDataItem.data = Utils.readByteString(bufferedSource, leb128).utf8();
            stringDataItems.add(stringDataItem);
        }
        return stringDataItems;
    }</code></pre></div>

<p>解析<code>string_data_item</code>的代码比较蛋疼，是因为我在使用我们产品的<code>.dex</code>文件时会出问题，读取的<code>uleb128</code>也就是字符串长度不对，可能数据区中存储不是连续的。结果如下，我把两种数据综合了一下：</p>

<table>
<thead>
<tr>
<th>index</th>
<th>string_data_off</th>
<th>utf16_size</th>
<th>data</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>374</td>
<td>6</td>
<td>&lt;init&gt;</td>
</tr>
<tr>
<td>1</td>
<td>382</td>
<td>12</td>
<td>Hello, Dex!</td>
</tr>
<tr>
<td>2</td>
<td>396</td>
<td>15</td>
<td>HelloWorld.java</td>
</tr>
<tr>
<td>3</td>
<td>413</td>
<td>12</td>
<td>LHelloWorld;</td>
</tr>
<tr>
<td>4</td>
<td>427</td>
<td>21</td>
<td>Ljava/io/PrintStream;</td>
</tr>
<tr>
<td>5</td>
<td>450</td>
<td>18</td>
<td>Ljava/lang/Object;</td>
</tr>
<tr>
<td>6</td>
<td>470</td>
<td>18</td>
<td>Ljava/lang/String;</td>
</tr>
<tr>
<td>7</td>
<td>490</td>
<td>18</td>
<td>Ljava/lang/System;</td>
</tr>
<tr>
<td>8</td>
<td>510</td>
<td>1</td>
<td>V</td>
</tr>
<tr>
<td>9</td>
<td>513</td>
<td>2</td>
<td>VL</td>
</tr>
<tr>
<td>10</td>
<td>517</td>
<td>19</td>
<td>[Ljava/lang/String;</td>
</tr>
<tr>
<td>11</td>
<td>538</td>
<td>4</td>
<td>main</td>
</tr>
<tr>
<td>12</td>
<td>544</td>
<td>3</td>
<td>out</td>
</tr>
<tr>
<td>13</td>
<td>549</td>
<td>7</td>
<td>println</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">Type、Proto、Field、Method</h3>

<p>这几种都不细说了，和字符串一样，结果整理如下：</p>

<p><code>type</code>:</p>

<table>
<thead>
<tr>
<th>index</th>
<th>descriptor_idx</th>
<th>descriptor</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>3</td>
<td>LHelloWorld;</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>Ljava/io/PrintStream;</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>Ljava/lang/Object;</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>Ljava/lang/String;</td>
</tr>
<tr>
<td>4</td>
<td>7</td>
<td>Ljava/lang/System;</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
<td>V</td>
</tr>
<tr>
<td>6</td>
<td>10</td>
<td>[Ljava/lang/String;</td>
</tr>
</tbody>
</table>

<p><code>prototype</code>:</p>

<table>
<thead>
<tr>
<th>index</th>
<th>shortyDesc</th>
<th>returnType</th>
<th>parameters size</th>
<th>parameters</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>V</td>
<td>V</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>VL</td>
<td>V</td>
<td>1</td>
<td>Ljava/lang/String;</td>
</tr>
<tr>
<td>2</td>
<td>VL</td>
<td>V</td>
<td>1</td>
<td>[Ljava/lang/String;</td>
</tr>
</tbody>
</table>

<p><code>field</code>:</p>

<table>
<thead>
<tr>
<th>index</th>
<th>name</th>
<th>definingClass</th>
<th>type</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>out</td>
<td>Ljava/lang/System;</td>
<td>Ljava/io/PrintStream;</td>
</tr>
</tbody>
</table>

<p><code>method</code>:</p>

<table>
<thead>
<tr>
<th>index</th>
<th>name</th>
<th>class</th>
<th>prototype</th>
<th>returnType</th>
<th>parameters size</th>
<th>parameters</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>&lt;init&gt;</td>
<td>LHelloWorld;</td>
<td>V</td>
<td>V</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>main</td>
<td>LHelloWorld;</td>
<td>VL</td>
<td>V</td>
<td>1</td>
<td>[Ljava/lang/String;</td>
</tr>
<tr>
<td>2</td>
<td>println</td>
<td>Ljava/io/PrintStream;</td>
<td>VL</td>
<td>V</td>
<td>1</td>
<td>Ljava/lang/String;</td>
</tr>
<tr>
<td>3</td>
<td>&lt;init&gt;</td>
<td>Ljava/lang/Object;</td>
<td>V</td>
<td>V</td>
<td>0</td>
<td>-</td>
</tr>
</tbody>
</table>

<h3 id="toc_8">ClassDef</h3>

<p>类的定义，解析过程和上面一样，看文档及源码就行了：</p>

<table>
<thead>
<tr>
<th>index</th>
<th>class</th>
<th>accessFlags</th>
<th>superClass</th>
<th>interfaces</th>
<th>sourceFile</th>
<th>annotations</th>
<th>staticValues</th>
<th>annotationsDirectoryItem</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>LHelloWorld;</td>
<td>ACC_PUBLIC</td>
<td>Ljava/lang/Object;</td>
<td>-</td>
<td>HelloWorld.java</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>

<p>上面是基本信息，其实还有一个<code>class_data_off</code>，指向<code>class_data_item</code>的位置，这个里面存储了当前<code>class</code>中<code>static</code>字段、实例字段、直接方法（direct methods，<code>private</code>或者构造方法）、虚方法（virtual methods，非<code>private</code>、<code>static</code>、<code>final</code>，非构造方法）的信息，在当前🌰中静态字段、实例字段、虚方法都没有，我们主要分析两个直接方法：</p>

<p><code>class_data_item</code>中的<code>direct_methods</code>编码方式为<code>encoded_method</code>，它里面描述了该方法在<code>method_ids</code>中的索引和修饰符（<code>method_ids</code>中没有修饰符）以及方法中代码块的位置（<code>code_off</code>），代码块的编码方式为<code>code_item</code>，解析<code>code_item</code>是我们将当前类定义翻译成smali语法的关键：</p>

<p><code>code_item</code>:</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>registers_size</code></td>
<td><code>ushort</code></td>
<td>当前代码块使用到的寄存器数量</td>
</tr>
<tr>
<td><code>ins_size</code></td>
<td><code>ushort</code></td>
<td>传入当前method的参数数量，后面的结果中默认的构造方法中这个值是1，原因是有个<code>this</code>，静态方法没<code>this</code></td>
</tr>
<tr>
<td><code>outs_size</code></td>
<td><code>ushort</code></td>
<td>当前代码块中调用其它方法的参数数量</td>
</tr>
<tr>
<td><code>tries_size</code></td>
<td><code>ushort</code></td>
<td>代码块中异常处理的数量</td>
</tr>
<tr>
<td><code>debug_info_off</code></td>
<td><code>uint</code></td>
<td>调试信息的位置，调试信息中包含3个值：当前代码块在源文件中的起始行数、方法的参数数量、方法参数名的列表</td>
</tr>
<tr>
<td><code>insns_size</code></td>
<td><code>uint</code></td>
<td>指令的数量，指令是16位编码的</td>
</tr>
<tr>
<td><code>insns</code></td>
<td><code>ushort</code></td>
<td>指令列表，详细信息在<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html">Dalvik bytecode</a></td>
</tr>
<tr>
<td><code>padding</code></td>
<td><code>ushort(optional)=0</code></td>
<td></td>
</tr>
<tr>
<td><code>tries</code></td>
<td><code>try_item[tries_size] (optional)</code></td>
<td></td>
</tr>
<tr>
<td><code>handlers</code></td>
<td><code>encoded_catch_handler_list (optional)</code></td>
<td></td>
</tr>
</tbody>
</table>

<p>先看两个<code>direct method</code>的<code>code_item</code>：</p>

<table>
<thead>
<tr>
<th>index</th>
<th>method</th>
<th>registerSize</th>
<th>insSize</th>
<th>outsSize</th>
<th>triesSize</th>
<th>debugInfoOff</th>
<th>insnsSize</th>
<th>insns</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td><code>&lt;init&gt;</code></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>558</td>
<td>4</td>
<td><code>1070 0003 0000 000e</code></td>
</tr>
<tr>
<td>1</td>
<td><code>main</code></td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>563</td>
<td>8</td>
<td><code>0062 0000 011a 0001 206e 0002 0010 000e</code></td>
</tr>
</tbody>
</table>

<p>先看默认构造方法的指令：<code>1070 0003 0000 000e</code>，从<a href="https://source.android.com/devices/tech/dalvik/instruction-formats.html">instruction formats</a>中得知，操作符<code>op</code>是在第一个<code>16bits</code>的低8位，这里<code>op=70</code>，从<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html">dalvik bytecode</a>中得知：<code>70: invoke-direct</code>，并且指令格式为<code>35c</code>，返回<strong>instruction formats</strong>中查询<code>35c</code>，得知格式为<code>A|G|op BBBB F|E|D|C</code>，查看语法，这里<code>A=1</code>，所以语法为<code>[A=1] op {vC}, kind@BBBB</code>，<code>BBBB</code>是<code>method_ids</code>中的索引，翻译一下，<code>1070 0003 0000</code>的含义就是：</p>

<p><code>invoke-direct {p0} Ljava/lang/Object;-&gt;&lt;init&gt;()V</code></p>

<p><code>000e</code>的含义是<code>return-void</code>，综合上面的信息都可以写出第一个方法的<code>smali</code>语法定义：</p>

<div><pre><code class="language-none">.method public constructor &lt;init&gt;()V
    .registers 1
    invoke-direct { p0 }, Ljava/lang/Object;-&gt;&lt;init&gt;()V
    return-void
.end method</code></pre></div>

<p>再看第二个<code>main</code>方法，<code>0062 0000 011a 0001 206e 0002 0010 000e</code>：</p>

<p><code>0062 0000</code>的意思为<code>sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</code></p>

<p><code>011a 0001</code>位<code>const-string v1, &quot;Hello, Dex!\n&quot;</code></p>

<p>最后的<code>206e 0002 0010</code>语法和<code>&lt;init&gt;</code>一样，解释为：<code>invoke-virtual { v0, v1 }, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</code></p>

<p>最终得到<code>main</code>方法：</p>

<div><pre><code class="language-none">.method public static main([Ljava/lang/String;)V
    .registers 3
    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;
    const-string v1, &quot;Hello, Dex!\n&quot;
    invoke-virtual { v0, v1 }, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V
    .line 4
    return-void
.end method</code></pre></div>

<p>使用Android SDK中的<code>dexdump</code>工具也可以看到<code>.dex</code>文件的详细信息：</p>

<div><pre><code class="language-none">➜  dex dexdump -d Hello.dex
Processing &#39;Hello.dex&#39;...
Opened &#39;Hello.dex&#39;, DEX version &#39;035&#39;
Class #0            -
  Class descriptor  : &#39;LHelloWorld;&#39;
  Access flags      : 0x0001 (PUBLIC)
  Superclass        : &#39;Ljava/lang/Object;&#39;
  Interfaces        -
  Static fields     -
  Instance fields   -
  Direct methods    -
    #0              : (in LHelloWorld;)
      name          : &#39;&lt;init&gt;&#39;
      type          : &#39;()V&#39;
      access        : 0x10001 (PUBLIC CONSTRUCTOR)
      code          -
      registers     : 1
      ins           : 1
      outs          : 1
      insns size    : 4 16-bit code units
000130:                                        |[000130] HelloWorld.&lt;init&gt;:()V
000140: 7010 0300 0000                         |0000: invoke-direct {v0}, Ljava/lang/Object;.&lt;init&gt;:()V // method@0003
000146: 0e00                                   |0003: return-void
      catches       : (none)
      positions     :
        0x0000 line=1
      locals        :
        0x0000 - 0x0004 reg=0 this LHelloWorld;

    #1              : (in LHelloWorld;)
      name          : &#39;main&#39;
      type          : &#39;([Ljava/lang/String;)V&#39;
      access        : 0x0009 (PUBLIC STATIC)
      code          -
      registers     : 3
      ins           : 1
      outs          : 2
      insns size    : 8 16-bit code units
000148:                                        |[000148] HelloWorld.main:([Ljava/lang/String;)V
000158: 6200 0000                              |0000: sget-object v0, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000
00015c: 1a01 0100                              |0002: const-string v1, &quot;Hello, Dex!
&quot; // string@0001
000160: 6e20 0200 1000                         |0004: invoke-virtual {v0, v1}, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@0002
000166: 0e00                                   |0007: return-void
      catches       : (none)
      positions     :
        0x0000 line=3
        0x0007 line=4
      locals        :

  Virtual methods   -
  source_file_idx   : 2 (HelloWorld.java)</code></pre></div>




</body>

</html>
